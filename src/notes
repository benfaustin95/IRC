Client design

While the cleint is running we are listening, if the server ever cant be reached we stop out input loop





#tasks for today in order, tested one after the other

Let me explain why you need to send a header, then a message.
recv is going to grab x amount of bytes. Lets start with are header
If headrs dont conform to the same byts every time your going to see what you would consider buffer overflow
but what it really is a you sedning under or over ur correct header size.
Then move on to message. Upon header's suscess recv we should process and get ready for messsage
recv message of x bytes. Its there all good no werid overflow
This is the cycle.
This IS BOTH LOGIC.
The only diff is for cleint right is we wnat to lock the ability to sendall to clinet iterively
For server we are threading each socket and no shared data..we all good sunglasses :sunglasses emoji





I think where we were going wrong with our code was with this idea right. As soon as a conneciton is made we need to go into multiple threads.
If we dont do this we must deal with non-blocking, asynchronous I/O handling. And if we are doing that then why are we doing threads right.
once you do accept and you not multithreaded at this point async handing must be done


The Receiv call dosent know how much to process so this is why we have to send it 2 parts, theres no way around it or u gonna expernce wierd overflows
the headers will all be the same size, they must be, then the message must be what it pormised to be





Non-Blocking Sockets

    Definition: Non-blocking sockets allow operations to return immediately, regardless of whether they can be completed. If an operation cannot be completed immediately,
                it returns an error indicating that it would block.

    Advantages:
        Scalability: Non-blocking sockets can handle a large number of connections efficiently, as they do not tie up resources waiting for operations to complete.
        Responsiveness: They allow your application to remain responsive, as the application can continue processing other tasks while waiting for socket operations to complete.

    Disadvantages:
        Complexity: Non-blocking sockets require more complex code to handle partial reads/writes and to manage the state of each connection.
        Polling Required: You often need to use mechanisms like select(), poll(), or epoll() to check which sockets are ready for reading or writing.

Blocking Sockets with Timeout

    Definition: Blocking sockets wait for an operation to complete before returning. By setting a timeout, you specify the maximum time the socket will wait for an operation to complete before raising an exception.

    Advantages:
        Simplicity: Blocking sockets are easier to implement and understand, as they follow a straightforward request-response model.
        Timeout Control: You can control how long the socket waits for an operation, which helps prevent the application from hanging indefinitely.

    Disadvantages:
        Limited Scalability: Blocking sockets can be less efficient when handling many connections, as each operation blocks the thread until it completes or times out.
        Potential Delays: If the timeout is too long, it can delay the processing of other tasks.

